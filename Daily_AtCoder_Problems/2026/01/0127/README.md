## [ C. 単調増加](https://atcoder.jp/contests/abc038/tasks/abc038_c)

考察双指针，严格单调递增子数组的个数为当前数组长度的 $\dfrac{size \times (size + 1)}{2}$ 。

所以我们可以枚举出所有严格单调递增的子数组再求和。

```python
l = ans = 0
while l < n:
    r = l + 1
    while r < n and a[r] - a[r-1] > 0:  # 这里是减去r-1处的元素而不是l
        r += 1
    cnt = r - l
    ans += cnt * (cnt + 1) // 2
    l = r
```

## [C. Security 2](https://atcoder.jp/contests/abc407/tasks/abc407_c)

考察模拟，因为先加入的数字（左边）会受到右边后来加入的数字的影响，所以我们应该从后往前推。

以样例2为例：

* 最后一个数字是直接由 $0$ 到达到 $7$ 的，所以这里就要按 $7$ 次。
* 倒数第二个数字受到倒数第一个的影响，它只能在接下来一定要按 $7$ 下的命运下从 $x$ 按 $7$ 下后到达 $0$ 。
* 所以可以推出倒数第二个是 $3$ 。此时已经按了 $7+3$ 下。
* 第一个在后两个的基础下按 $10$ 到达 $4$ 的话，第一个就是 $4$ 。
* 此时一共按了 $7+3+4$ 下，再加上 $3$ 个最基础的 $0$ ，一共 $17$ 。

思路就是这样，接下来就是模拟了。