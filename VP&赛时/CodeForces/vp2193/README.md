## 赛后复盘

已过ABCDE，赛时ABCD。

AB简单，C贪心策略明显但是WA了1发，D想到了但是超时了。

### **A. DBMB and the Array**

可以将 $x$ 加入数组中任意次，判断数组的和可不可以等于 $s$ 。直接让 $s$ 和原数组的和相减判断大于等于 $0$ 和是 $x$ 的倍数即可。

### **B. Reverse a Permutation**

长度为 $n$ 的排列，翻转一次尽量让数组的字典序大，字典序最大的排列为 $n,n-1,n-2,···,2,1$ 所以只需要判断当前位的最大在不在正确的位置上，不在的话将这个区间翻转即可，考虑双指针。

### **C. Replace and Sum**                                                                                                                      

先根据条件求出 $a$ 数组的最有情况。

* 从后往前遍历，将大的元素往前移。
* 将 $b$ 中对应位置的更大的元素赋到 $a$ 中。

这样 $a$ 就是最优的了，然后预处理前缀和即可查询。

### **D. Monster Game**

将剑逆序排序后，枚举每一个剑，当前剑和剑左边的都是可以使用的。又剑越多可以通关的关卡是越多的，满足单调性，考虑双指针。

时间复杂度 $O(n)$ 一次遍历即可。

### **E. Product Queries**

一个数可以重复使用，但是它给的数组中还是有重复的数，所以先排好序去重。

又因为是第一次出现的数，考虑BFS。遍历一次先将已经出现的赋为 $1$ ，剩余的再此基础上进行递推。直到碎裂中元素全部弹出为止。

还可以使用DP。