## 赛后复盘

A、B、D简单，C用错方法了。总的来说偏简单。但是有失误的地方。

EFG不会，但让AI给出了简单的总结，为了让自己慢慢适应一些常见的算法常考点。

### **A - Welcome to AtCoder Land**

直接比较给出的字符串即可。

### **B - Ticket Counter**

第一个人的时间是 $a_1+A$ ，其他人的时间都要在前一个人买完后才可以开始买，即要来的时间要和前一个人结束的时间取一个 $\max$ 。

这里有一个失误，忘记更新**当前人结束的时间变量**。

### **C - Popcorn**

这里看数据量 $(1\le N,M\le10)$ 可以知道是属于搜索、枚举、全排列等算法，我一开始使用的是全排列枚举所有可能的情况再一一取 $\min$ ，时间复杂度是 $N!\times N\times M$ 。虽然有剪枝，但还是有一个点过不了。

使用二进制枚举，时 间复杂度 $2^N \times N \times M$ 直接从 $10!(3628800)$ 优化到了 $2^{10}(1024)$ 。

当上述两种方法都可以优化，即通过**位掩码**将最内层的字符串遍历优化掉，将时间复杂度优化至:

* $O(N!\times N)$
* $O(2^N\times N)$

更优做法是状压DP，但是这里还没有学过，先不讨论。时间复杂度是 $N\times 2^M$ 。

### **D - Souvenirs**

分别对两个数组排序后，使用双指针即可，比C要简单多了。

### **E - Alphabet Tiles**

**计数类 DP**。考查如何用组合数 $C_n^k$ 处理“相同字符的排列”问题。

### **F - Easiest Maze**

**路径构造**。考查在网格图中通过特定形状（如蛇形线）构造出长度为 $K$ 的路径。

### **G - AtCoder Tour**

**步数极大的路径最优化**。关键在于发现：如果步数非常多，最优策略一定是走到某个高分格子后“原地踏步”。