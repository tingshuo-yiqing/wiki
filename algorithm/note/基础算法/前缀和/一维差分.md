对于一个给定的序列，他的差分数组为: 


$$
b_i=
\begin{cases}
b_1=a_1&\\
b_i=a_i-a_{i-1}&(2\le i\le n)
\end{cases}
$$


一般差分会多开两个大小防止越界。

```python
nums = [0] + list(map(int, input().split()))

diff = [0] * (n + 2)
for i in range(1, n + 1):
    diff[i] = nums[i] - nums[i - 1]
```

$diff$ 是 $nums$ 的差分序列， $nums$ 是 $diff$ 的前缀和序列，差分序列和前缀和序列是一对互逆运算。

当想对序列的的区间进行操作时亏转化为在其差分序列上的两点操作最后再前缀和还原，时间复杂度从 $O(N^2)$ 到 $O(N)$ 。不过缺点也很明显: 只能静态查询。

```python
for _ in range(q):
    l, r, x = map(int, input().split())
    diff[l] += x
    diff[r + 1] -= x   # 多开一个这里防止越界

cur = 0
for i in range(1, n + 1):
    cur += diff[i]  # cur就是对应的前缀和
```

## 应用

一个常见的题型——加一减一最小操作次数使数组元素都相等

* [P4552](https://www.luogu.com.cn/problem/P4552)

得到差分数组后，只需要将 $b_2$ 到 $b_n$ 的元素值全部变为 $0$ 则原数组的值就全部相等且为 $b_1$ 。具体的操作方式有四种: 

1. $2 \le L,\ R + 1 \le n$：这是最高效的。我们可以选一个正的 $b_i$ 和一个负的 $b_j$，让正的减 $1$，负的加 $1$。 这样一步操作就能让两个数都向 $0$ 靠近。
   
2. $L = 1,\ 2 \le R + 1 \le n$：改变 $b_{R+1}$ 的同时改变了 $b_1$（最终的相等值）。
   
3. $2 \le L \le n,\ R + 1 = n + 1$：只改变 $b_L$，不影响 $b_1$。
   
4. $L = 1,\ R + 1 = n + 1$：同时改变 $b_1$ 和 $b_{n+1}$，对把 $b_2,\ldots,b_n$ 变为 $0$ 没有任何帮助，属于浪费操作。

### 1.多改一查

最常见的应用是数组里经过一系列操作、标记等处理后再一次性输出。

* [P2367](https://www.luogu.com.cn/problem/P2367)
* [ABC 419-D](https://atcoder.jp/contests/abc419/tasks/abc419_d)



### 2.一改一查

这里可以维护局部贡献最终