## 经典前缀和

将数组多开一/两个位置便于查询，查询时将下标转化为 `0-based` 。

### 预处理

手动遍历：

```python
ppf = [0] * (n + 1)
for i in range(1, n + 1):
    ppf[i] = ppf[i - 1] + nums[i]

ssf = [0] * (n + 2)   # 这里要多开一位
for i in range(n, 0, -1):
    ssf[i] = ssf[i + 1] + nums[i]
```

使用库函数：

```python
from itertools import accumulate

nums = [0] + [1, 2, 3, 4, 5]
pf = list(accumulate(nums))

sf = list(accumulate(nums[::-1]))[::-1] + [0] # 后缀和
```

### 查询

```python
for _ in range(3):
    l, r = map(lambda x: int(x)-1, input().split())  # 先转化成 0-based
    print(pf[r+1] - pf[l])  # 查询 [l, r] 之间的和
```

## 扩展

### 前后缀GCD

预处理后，当要快速计算区间 $\gcd$ 时非常高效便捷。比如模拟删除 $i$ 位置的元素后剩下元素的 $\gcd$ 。

```python
ans = 0
for i in range(1, n + 1):
    # 模拟删除操作，不包含A[i]的前后缀gcd的gcd
    ans = max(ans, gcd(pf[i - 1], sf[i + 1]))
```

### 前缀异或

预处理后，亏快速求区间异或。

```python
px = [0] * (n + 1)
for i in range(1, n + 1):
    px[i] = px[i - 1] ^ A[i]
    
def query_xor(l, r):  
    return px[r + 1] ^ px[l]
```

### 前缀mex

$\text{mex}$ 是单调递增的，通过一次遍历可以预处理出前后缀的 $\text{mex}$ : 

```python
def get_mex(nums):
    n = len(nums)
    ret = []
    exit_number = set()

    cur = 0
    for i in range(n):
        exit_number.add(nums[i])
        while cur in exit_number:
            cur += 1
        ret.append(cur)
    return ret

pf = get_mex(nums)  # 前缀mex
sf = get_mex(nums[::-1])[::-1]  # 后缀mex
```

若要把数组分割成 $\text{mex}$ 相等的 $k$ 段，这个相等的 $\text{mex}$ 就是全局的 $\text{mex}$ 。

先考虑两段：通过前后缀分解可以一次遍历找出一个点将数组分割成 $\text{mex}$ 相等的两段。
$k$ 段的话一次遍历当子数组的 $\text{mex}$ 等于全局的时就截断，最终段数大于等于 $k$ 就可以分成。

一次遍历通过计算集合的大小来判断当前子数组是否达到全局 $\text{mex}$ 。

### 前缀倍数

整除的结果就是区间内除数的倍数的个数。

```python
c = b // a # [1, b]之间a的倍数的个数

def count(a, b, x):
    return b // x - (a - 1) // x # [a, b]之间x的倍数的个数
```

也可以通过这个性质来求约数个数，因为倍数其实就是约数。

## 例题:

* [ABC Neq Min](https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_c) 前缀 $\text{mex}$
* [CF1935B](https://codeforces.com/contest/1935/problem/B) 前缀 $\text{mex}$
* [ABC 131-C](https://atcoder.jp/contests/abc131/tasks/abc131_c)  前缀倍数
