## 经典前缀和

将数组多开一个位置便于查询，查询时将下标转化为 `0-based` 。

### 预处理

手动遍历：

```python
pf = [0] * (n + 1)
for i in range(1, n + 1):
    pf[i] = pf[i - 1] + nums[i]

sf = [0] * (n + 1)   # 这里要多开一位
for i in range(n-1, -1, -1):
    sf[i] = sf[i + 1] + nums[i]
```

使用库函数：

```python
from itertools import accumulate

nums = [0] + [1, 2, 3, 4, 5]
pf = list(accumulate(nums))

sf = list(accumulate(nums[::-1]))[::-1] + [0] # 后缀和
```

### 查询

```python
for _ in range(3):
    l, r = map(lambda x: int(x)-1, input().split())  # 先转化成 0-based
    print(pf[r+1] - pf[l])  # 查询 [l, r] 之间的和
```

## 扩展

### 环形前缀和

[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/) [Rotate and Sum Query](https://atcoder.jp/contests/abc425/tasks/abc425_c) 

查询环形的区间和时，把数组复制到数组末尾后预处理 $2\times N$ 的前缀和，只需要知道**查询区间的长度** $length$ 即可通过查询公式计算：



$$
\mathrm{length}=(r - l + n) \pmod n + 1 \\
\mathrm{Sum}=pf_{l+length}-pf_l
$$



这里的 $l,r$ 都是 0-based 的。

### 前后缀GCD

预处理后，当要快速计算区间 $\gcd$ 时非常高效便捷。比如模拟删除 $i$ 位置的元素后剩下元素的 $\gcd$ 。

```python
ans = 0
for i in range(1, n + 1):
    # 模拟删除操作，不包含A[i]的前后缀gcd的gcd
    ans = max(ans, gcd(pf[i - 1], sf[i + 1]))
```

### 前缀异或

预处理后，亏快速求区间异或。

```python
px = [0] * (n + 1)
for i in range(1, n + 1):
    px[i] = px[i - 1] ^ A[i]
    
def query_xor(l, r):  
    return px[r + 1] ^ px[l]
```

查询的话是将两个端点进行异或而不是简单的做减法了：

```python
pf[r] ^ pf[l - 1]  # 1-based
```

### 前缀mex

$\text{mex}$ 是单调递增的，通过一次遍历可以预处理出前后缀的 $\text{mex}$ : 

```python
def get_mex(nums):
    n = len(nums)
    ret = []
    exit_number = set()

    cur = 0
    for i in range(n):
        exit_number.add(nums[i])
        while cur in exit_number:
            cur += 1
        ret.append(cur)
    return ret

pf = get_mex(nums)  # 前缀mex
sf = get_mex(nums[::-1])[::-1]  # 后缀mex
```

若要把数组分割成 $\text{mex}$ 相等的 $k$ 段，这个相等的 $\text{mex}$ 就是全局的 $\text{mex}$ 。

先考虑两段：通过前后缀分解可以一次遍历找出一个点将数组分割成 $\text{mex}$ 相等的两段。
$k$ 段的话一次遍历当子数组的 $\text{mex}$ 等于全局的时就截断，最终段数大于等于 $k$ 就可以分成。

一次遍历通过计算集合的大小来判断当前子数组是否达到全局 $\text{mex}$ 。

### 前缀倍数

整除的结果就是区间内除数的倍数的个数。

```python
c = b // a # [1, b]之间a的倍数的个数

def count(a, b, x):
    return b // x - (a - 1) // x # [a, b]之间x的倍数的个数
```

也可以通过这个性质来求约数个数，因为倍数其实就是约数。

### 前缀模数

数组整体的模数（Total Sum mod $p$）与子数组的模数（Subarray Sum mod $p$）之间存在着非常紧密的**线性补数关系**。这种关系是解决“子数组和整除”、“最少删除子数组使剩余部分整除”等问题的核心数学基础。

我们可以通过**前缀和（Prefix Sum）**这一工具将它们联系起来。


$$
\mathrm{SubSum}(i,j)=P_j-P_{i-1}\\
\mathrm{SubSum}(i,j)\equiv(P_j-P_{i-1})\quad(\mathrm{mod~}p)
$$


常见应用：目标补全，比如删除一段子数组后剩下元素的模数。[1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/)

* 设元素总和模 $p$ 为 $k$ 即 $\mathrm{S} \equiv k \pmod{p}$
* 删除一个子数组也模 $p$ 也为 $k$  即 $\mathrm{SubSum} \equiv k\pmod{p}$ 
* 那么剩余元素满足 $\mathrm{Rem\equiv (S-SubSum)}\equiv(k-k)\equiv0\pmod{p}$ 

配合哈希表可以满足上述条件，不过要注意初始化 `{0:-1}` 。

## 例题:

* [ABC Neq Min](https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_c) 前缀 $\text{mex}$
* [CF1935B](https://codeforces.com/contest/1935/problem/B) 前缀 $\text{mex}$
* [ABC 131-C](https://atcoder.jp/contests/abc131/tasks/abc131_c)  前缀倍数
