## 经典前缀和

将数组多开一/两个位置便于查询，查询时将下标转化为 `0-based` 。

### 预处理

手动遍历：

```python
ppf = [0] * (n + 1)
for i in range(1, n + 1):
    ppf[i] = ppf[i - 1] + nums[i]

ssf = [0] * (n + 2)   # 这里要多开一位
for i in range(n, 0, -1):
    ssf[i] = ssf[i + 1] + nums[i]
```

使用库函数：

```python
from itertools import accumulate

nums = [0] + [1, 2, 3, 4, 5]
pf = list(accumulate(nums))

sf = list(accumulate(nums[::-1]))[::-1] + [0] # 后缀和
```

### 查询

```python
for _ in range(3):
    l, r = map(lambda x: int(x)-1, input().split())  # 先转化成 0-based
    print(pf[r+1] - pf[l])  # 查询 [l, r] 之间的和
```

## 扩展

### 前后缀GCD

预处理后，当要快速计算区间 $\gcd$ 时非常高效便捷。比如模拟删除 $i$ 位置的元素后剩下元素的 $\gcd$ 。

```python
ans = 0
for i in range(1, n + 1):
    # 模拟删除操作，不包含A[i]的前后缀gcd的gcd
    ans = max(ans, gcd(pf[i - 1], sf[i + 1]))
```

### 前缀异或

预处理后，亏快速求区间异或。

```python
px = [0] * (n + 1)
for i in range(1, n + 1):
    px[i] = px[i - 1] ^ A[i]
    
def query_xor(l, r):  
    return px[r + 1] ^ px[l]
```

### 例题：

* [ABC125C GCD on Blackboard](https://atcoder.jp/contests/abc125/tasks/abc125_c)
* [E-小苯的01合并](https://ac.nowcoder.com/acm/contest/126319/D)
