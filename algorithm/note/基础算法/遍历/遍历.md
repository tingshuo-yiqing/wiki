### 分段计数

一次遍历统计符合条件的片段数，不能忘记**最后一段**

 [小红的01串（二）](https://www.nowcoder.com/practice/648c2f2c57b848c1860d3e1375178b8c?tpId=391&channelPut=tracker1)，分段计数`01`串的长度

```python
s = input()

ans = []
cnt = 1

for i in range(len(s) - 1):
    if s[i] != s[i + 1]:   # 这里最后满足的话，不会到else加入到ans中
        cnt += 1
    else:
        ans.append(cnt)
        cnt = 1

ans.append(cnt)  # 最后一段

print(sum(n * (n - 1) // 2 for n in ans))
```

## 贡献法

### 思想

与其枚举每一个目标结果，不如计算每一个元素最终对目标结果的影响

### 常见应用

[ D - Sum of Differences](https://atcoder.jp/contests/abc437/tasks/abc437_d)，内部遍历要么是$a[i]-b[j]$要么是$b[j] - a[i]$，所以我们可以直接统计它们出现的次数计算不用遍历。对`b`数组排序前缀和，然后二分出$a[i]$的位置即可

[区间求和](https://bs.daimayuan.top/p/3)，直接计算每个元素前后有多少个区间，再乘法原理

[子数组的最小值之和](https://www.google.com/url?sa=E&q=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsum-of-subarray-minimums%2F)，使用**单调栈**辅助寻找最值（确定各包含了多少区间），再乘法原理

[2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/)，

[子序列宽度之和](https://www.google.com/url?sa=E&q=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsum-of-subsequence-widths%2F)

[汉明距离总和](https://leetcode.cn/problems/total-hamming-distance/)

[树上所有路径的距离之和]

[统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)
