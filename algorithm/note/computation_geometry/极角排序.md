## 基础概念

一般选择平面上一点 $O$ 为极点，那么每个点相对极点都有极坐标 $(\rho,\theta)$ ，对这些极坐标按角度 $\theta$ 的排序就是极角排序。

[T269230 极角排序](https://www.luogu.com.cn/problem/T269230) 

## 实现

一般有两种实现方式：

* 直接调用库函数 $atan2$ 
* 整数域下使用差积

### 利用atan2函数的排序

计算极角时我们可以直接使用数学函数 $\atan$ ，但它的值域为 $(-\dfrac{\pi}{2},\dfrac{\pi}{2})$  ，而且当 $x=0$ 时无定义需要复杂的分类讨论，于是我们一般使用另一个语言内置的 $\atan2(y,x)$ 来直接计算点 $(x,y)$ 的极角。

这是最直接的方式**实现简单时间短**，但是它可能在后续中计算**容易被卡精度**。

具体实现为：

```python
# points是坐标列表，包含 (x, y) 元组坐标
points.sort(key=lambda x: (
    # 这里为什么不直接 atan2(x[1], x[0]) 而要将负角度转化为正的呢？
    # 因为题目规定 令零向量极角为 0 是绝对顺序。
    # 有的题目只需要相对顺序就可以了(即是一个环)，比如 https://codeforces.com/contest/598/problem/C
    atan2(x[1], x[0]) if atan2(x[1], x[0]) >= 0 else atan2(x[1], x[0]) + 2*pi,
    dist(x, (0, 0)) # 这里是按题目要求: 极角相同按距离排
))
```

$atan2$ 返回的可能是负数，需要加 $2\pi$ 进行转化为正的，因为我们期望这些点按从 $x$ 轴正半轴开始逆时针旋转一周排序需要的值域是 $[0,2\pi]$ 。如果是 $(-\pi,\pi]$ 的话，**位于 $x$ 轴下方的点会因为角度是负数，被排在 $x$ 轴正半轴的点之前。**

### 整数域下利用差积的排序

这里先区分象限，再比较差积

```python
cross = lambda x, y: x[0]*y[1] - x[1]*y[0]

def polarLess(x, y):
    """ 必须要明确返回值 [-1小于, 0等于, 1大于] 不能返回True和False """
    top = lambda x: x[1] < 0 or (x[1] == 0 and x[0] < 0)
    px = top(x)
    py = top(y)
    if px != py:
        return -1 if not px else 1
    cp = cross(x, y)
    if cp != 0:
        return -1 if cp > 0 else 1
    return 0
```

