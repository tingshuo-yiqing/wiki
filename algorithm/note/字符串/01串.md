## 子序列与回文串

这类一般是，去掉特殊的子序列后得到一个回文串。这时我们一般会全部去0或去1

[B. Beautiful String](https://codeforces.com/contest/2162/problem/B)、[Palindrome Coloring](https://www.nowcoder.com/practice/a9b9018c730747d2b117a3d1bfcc3ae9?tpId=391&channelPut=w251acm)

[CodeForces - 2114B ](https://vjudge.net/problem/CodeForces-2114B/origin)

## 反转

只有两种方式，一般是0变1和1变0，所以**反转的次数的记录**很重要

[ 历史上的今天](https://ac.nowcoder.com/acm/contest/121107/K)，遍历到`1`时将后面的字符反转

* 容易知道：后面的反转次数取决于前面的1的个数

* 所以统计1的个数

* 注意字符串字面量不能改，转成字符数组再join连接

```python
s = list(input())
cnt = 0
for i in range(n):
    if cnt & 1:
        s[i] = '1' if s[i] == '0' else '0'
    if s[i] == '1':
        cnt += 1
print(''.join(s))    
```

## 交替串

[小红的01串修改](https://ac.nowcoder.com/acm/contest/114111/C)，操作为选择相邻的字符（长度为2的子串）将其反置。**直接向两个最终结果模拟**，如何判断能不能达到

```python
def flip(s_list, t_list):
    s = s_list[:]  # list是可变类型，函数内部修改会影响到全局，所以应该拷贝一份
    ret = 0
    for i in range(len(s)-1):
        if s[i] != t_list[i]:
            s[i] ^= 1
            s[i+1] ^= 1
            ret += 1
    return ret if s == t_list else inf  # 不相等说明达不到

s = list(map(int, s))
t0 = [i % 2 for i in range(n)]
t1 = [i % 2 for i in range(1, n+1)]
# 模拟到两个目标
cnt0 = flip(s, t0)
cnt1 = flip(s, t1)

ans = min(cnt1, cnt0)
outs.append(ans if ans != inf else -1) # 两个都不行就是-1
```

[C - Alternated](https://atcoder.jp/contests/abc421/tasks/abc421_c)，操作为交换两个字符，此时与两个目标串进行对比取`min`

```python
idx = []

for i in range(n*2):
    if s[i] == 'A':
        idx.append(i)

cntA = cntB = 0

for i in range(n):
    idxa = 2 * i
    cntA += abs(idx[i] - idxa)  # ABABAB
    cntB += abs(idx[i] - idxa-1)  # BABABA

print(min(cntA, cntB))
```

