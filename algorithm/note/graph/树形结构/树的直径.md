## 两次BFS

因为 Python 使用两次 DFS递归调用消耗太大可能会 MLE 或 TLE 所以推荐使用两次 BFS。

这种方法只可以处理正边权，优点是方便记录直径的路径。

```python
def bfs(start):
    dist = [-1] * (n + 1)
    dist[start] = 0

    mxd = 0
    res = start

    dq = deque([start])
    while dq:
        u = dq.popleft()
        if dist[u] > mxd:
            res = u
            mxd = dist[u]
        for v in g[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                dq.append(v)
    return res, mxd  # 返回与start最远的节点和它们的距离
# 测试链接: https://www.luogu.com.cn/problem/B4016
```

一定要使用两次 DFS 的话需要切换 Python3 编译器。

```python
c = 0
dist = [-1] * (n + 1)
def dfs(u, p=0):
    nonlocal c
    for v in g[u]:
        if v == p:
            continue
        dist[v] = dist[u] + 1
        if dist[v] > dist[c]:
            c = v
        dfs(v, u)

dfs(1)
dist[c] = 0
dfs(c)
print(dist[c])
# 测试链接: https://www.luogu.com.cn/problem/B4016
```



## 树形DP

可以处理负边权，但是不方便记录直径的路径。

这里使用 Pyhon3 编译器，不然会 MLE

```python

# 测试链接: https://www.luogu.com.cn/problem/B4016
```

