## 判定

本质是判断**图中有没有奇环**，可以使用 dfs 和 bfs 两种方法，本质是相同的。序要注意的是，图不一定是连通的所以需要枚举所有没有染过的点进行判断。

```python
color = [0] * (n + 1)
def bfs(u):
    dq = deque([u])
    color[u] = 1
    while dq:
        x = dq.popleft()
        c = color[x]
        for y in g[x]:
            if color[y] == 0:
                color[y] = 3 - c
                dq.append(y)
            elif color[y] == c:
                return True
    return False
# 测试链接: https://cses.fi/problemset/task/1668
```

推荐使用 bfs 的方法，因为递归可能会暴栈。

```python
color = [0] * (n + 1)
def dfs(u, c):
    color[u] = c
    for v in g[u]:
        if color[v] == 0:
            if dfs(v, 3-c):
                return True
        elif color[v] == c:
            return True
    return False
# 测试链接: https://cses.fi/problemset/task/1668
```

## 最大匹配

