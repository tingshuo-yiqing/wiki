树状数组（Binary Indexed Tree, BIT，也称 Fenwick Tree）是算法竞赛中极其常用的数据结构。它的核心优势在于：**代码短小精悍、常数极小、内存占用少**。

虽然它的功能是线段树的子集，但在处理“动态前缀和”相关问题时，BIT 通常是首选。以下是 BIT 的常见作用和典型应用模型：

## 1. 基础三大模型（核心用法）

这是树状数组最基本的演变形式，主要通过**差分思想**实现功能的切换。





## 2. 统计类模型

这类问题通常与“值域”有关，即将数值作为 BIT 的下标。

#### ① 逆序对 / 正序对 / 三元组统计
- **模型**：给定序列，统计满足 $i < j$ 且 $a[i] > a[j]$ 的对数。
- **做法**：
    1. 离散化（如果数值范围大）。
    2. 从左往右遍历序列。
    3. 先查询 BIT 中大于当前数 $a[j]$ 的个数（即已出现的、比它大的数）。
    4. 将当前数 $a[j]$ 插入 BIT（`update(a[j], 1)`）。
- **扩展**：如你刚才问的那道题，将“条件”转化为前缀和的大小关系，本质就是统计正序对。

#### ② 动态第 K 小（离散化 + 树状数组二分）
- **模型**：集合中不断加入/删除数，查询当前集合第 $k$ 小的数。
- **做法**：BIT 维护频率（下标是数值，`update(val, 1)`）。
- **技巧**：不需要在 `query` 上套 $O(\log n)$ 的二分（会变成 $O(\log^2 n)$），可以利用 BIT 结构的二进制特性进行**倍增（Binary Lifting）**，在 $O(\log n)$ 时间内找到第 $k$ 小。
