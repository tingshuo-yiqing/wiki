## 概念



## 求解乘法逆元的方法

### Exgcd

适合求单个整数的逆元，时间复杂度 $\log{p}$ 

```python
def exinv(a, m):
    d, x, y = exgcd(a, m)  # 扩欧模板
    if d != 1:
        return None
   	return x % m   # Python负数直接模成正数
```

### 快速幂

适合求单个整数的逆元。根据费马小定理有 $a^{p-1}\equiv 1\pmod{p}$ 再变形为 $a\times a^{p-2}\equiv 1\pmod{p}$ 则 $a$ 在模 $p$ 下的逆元为 $a^{p-2}$ ，可以使用快速幂求解，时间复杂度 $\log(p-2)$ 。使用之前需检查一下 $a$ 与 $p$ 是否互质且 $p$ 一定要是质数，否则换扩展欧几里得算法求解。

```python
inv = pow(a, p-2, p)
```

在 Python3.8+ 中使用快速幂计算逆元可以直接使用 `pow` ， `pow(a, -1, p)` 和上面的式子得到的相同的结果。

### 线性算法

对于一连串的数字求 $\mod{p}$  的逆元，只能使用这种方法，其它求单个的没有这个递推的快。

```python
inv = [0] * (n + 1)
inv[1] = 1

for i in range(2, n + 1):
    inv[i] = (p - p // i) * inv[p % i] % p
# 测试链接: https://www.luogu.com.cn/problem/P3811
```

### 阶乘逆元

当 MOD 是**质数**且大于 MAXN 时才可以使用此方法，否则考虑扩欧。通常用于求组合数。

```python
MAXN = 10 ** 6 + 1
MOD = 10 ** 9 + 7

facts = [1] * MAXN
inv = [1] * MAXN

for i in range(2, MAXN):
    facts[i] = i * facts[i - 1] % MOD

inv[MAXN - 1] = pow(facts[MAXN-1], MOD-2, MOD)
for i in range(MAXN-2, -1, -1):
    inv[i] = (i + 1) * inv[i + 1] % MOD
# 测试链接: https://vjudge.net/problem/CSES-1079
```

## 指数取模（降幂）

当指数特别大时，需要使用欧拉定理进行降幂。

* 如果 $gcd(a,m)=1$ ， $a^b \equiv a^{b\pmod{\phi(m)}}\pmod{m}$ 
* 通式（扩展欧拉定理）， $$ 

指数部分对 $\phi(m)$ 取模而不是对 $m$ 取模。

[Exponentiation II](https://vjudge.net/problem/CSES-1712)  模板题，MOD 是一个大指数，所以指数直接对 $10^9+6$ 取模即可。
