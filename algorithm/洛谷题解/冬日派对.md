不难看出，如果同时间只能参加其中一个活动的话，参加那个费用最小的。 

所以，我们只需要去重后按最小费用排序即可。由于数据较大，可能需要优化 `IO` 

## c++

c++的哈希表有两种:

* `map`：有序，默认小到大
* `unorder_map`：无序，一般使用这个，而且不能直接对其排序下面会将费用转化为数组，再排序。

```cpp
#include<bits/stdc++.h>
using namespace std;

using i64 = long long;
using u32 = unsigned;
using u64 = unsigned long long;

int main() {
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    i64 n, m;   // 最大 10^14
    cin >> n >> m;

    unordered_map<int, int> mp;  
    for (int i = 0; i < n; ++i) {
        int a, b;
        cin >> a >> b;

        if (!mp.count(a) || b < mp[a])
            mp[a] = b;
    }
	
    vector<int> costs;
    for (auto [time, cost] : mp)
        costs.push_back(cost);   // 不需要时间，只需要费用

    sort(costs.begin(), costs.end());

    int ans = 0;
    for (auto c : costs) {
        if (m >= c) {
            ans += 1;
            m -= c;
        }
    }

    cout << ans << '\n';
    return 0;
}
```

## python

```python
import sys
sys.setrecursionlimit(200000)

input = lambda: sys.stdin.readline().strip()

def main():
    n, m = map(int, input().split())

    costs = {}

    for _ in range(n):
        a, b = map(int, input().split())

        if a not in costs or b < costs[a]:
            costs[a] = b
    
    cnt = 0
    for c in sorted(costs.values()):
        if m >= c:
            m -= c
            cnt += 1
        else:
            break
    
    print(cnt)

if __name__ == "__main__":
    main()
```

