## 模拟操作

### 天数数组：

```python
months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
```

将下标映射成天数

### 判断闰年：

```python
def is_leap(n):
    return n % 400 == 0 or (n % 4 == 0 and n % 100 != 0)
```

* 可以被`400`整除
* 可以被`4`整除但不能被`1001`整除

### 补全前导0：

```python
def lead_zero(n, width):
    return str(n).zfill(width)  # 补前导0
```

使用`zfill()`内置函数

### 遍历：

```python
for y in range(2000, 2025):
    months[2] = 28 + is_leap(y)  # 特判2月
    for m in range(1, 13):
        for d in range(1, months[m] + 1):
            # 处理逻辑
            date = f"{lead_zero(y, 4)}-{lead_zero(m, 2)}-{lead_zero(d, 2)}" 
            print(date)
```

[回文日期](https://www.nowcoder.com/practice/0372242deac541d0b578cc6563395681?channelPut=tracker2)，枚举月日构造年，判断年是不是在合法区间内

[艺术与篮球](https://www.lanqiao.cn/problems/19937/learning/)，映射一个笔画数组，直接模拟遍历即可

[计算一年中的第几天](https://www.nowcoder.com/practice/178aa3dafb144bb8b0445edb5e9b812a?tpId=385&tqId=145342&channelPut=tracker1)，累加到上一个月的所有天数，再加上这个月的天数即可

## datatime库使用

`datetime`库可以很方便的计算日期差值。要时刻注意对象的功能，不要搞错了`date`和`timedelta`

```python
from datetime import date, timedelta
import calendar

d1 = date(year=2011, month=4, day=12) # 显示创建
d2 = date(2011, 4, 22) 

while d2 >= d1:  # 日期可以比较，通过这个来遍历比三层循环更简洁
    # 处理逻辑
    d1.year
    d1.month
    d1.day
    print(d1.strftime("%Y-%m-%d"))  # 日期格式化为字符串
    d1 -= timedelta(days=1)  # 往前推一天
    d1 += timedelta(weeks=1)  # 往后推一周 

print(d1.weekday())  # [0, 6], 0是星期日
print(d1.isoweekday())  # [1, 7]
print(calendar.isleap(d1.year))   # 判断是否是闰年，False
```

[星期一](https://www.lanqiao.cn/problems/611/learning/?page=1&first_category_id=1&tag_relation=union&name=%E6%98%9F%E6%9C%9F%E4%B8%80)，使用`isoweekday()`判断是否等于`1`

[下一次生日](https://www.lanqiao.cn/problems/19848/learning/?page=5&first_category_id=1&tags=%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97,%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98,%E8%AF%AD%E6%B3%95&tag_relation=union)，判断闰年。题目意义不明确，输出的是下一个润年不是天数
